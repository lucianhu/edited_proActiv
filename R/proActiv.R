#' Estimates promoter counts and activity in a single command
#'
#' @param files A character vector. The list of input files for 
#'   which the junction read counts will be calculated
#' @param promoterAnnotation A PromoterAnnotation object containing the
#'   intron ranges, promoter coordinates and the promoter id mapping
#' @param fileLabels A character vector. The labels of input files 
#'   for which the junction read counts will be calculated. These labels will be 
#'   used as column names for each output data.frame object. If not provided,
#'   filenames will be used as labels. Defaults to NULL
#' @param condition A character vector. The condition to which each sample
#'   belong to. Must correspond to the order of the files. If supplied, 
#'   results are summarized by condition. Defaults to NULL
#' @param genome A character. Genome version. Must be specified if input file
#'   type is a BAM file. Defaults to NULL
#' @param ncores A numeric value. The number of cores to be used for 
#'   counting junction reads. Defaults to 1 (no parallelization). This parameter 
#'   will be used as an argument to BiocParallel::bplapply
#' @param fileType Character string indicating the type of input files. 
#'   If set to `"salmon"`, the function expects transcript-level counts 
#'   generated by Salmon. If `NULL` (default), the file type will be inferred 
#'   automatically from the file extension.
#' @param apply_filter Logical indicating whether to apply filtering for 
#'   salmon files. Defaults to TRUE
#' @param min_count Minimum count threshold for filtering salmon files. 
#'   Defaults to 10
#' @param min_prop Minimum proportion threshold for filtering salmon files. 
#'   Defaults to 0.7
#'
#' @export
#' @return A SummarizedExperiment object with assays giving promoter counts 
#'   and activity with gene expression. rowData contains
#'   promoter metadata and absolute promoter activity summarized across
#'   conditions (if condition is provided)
#' 
#' @examples
#' 
#' files <- list.files(system.file('extdata/vignette/junctions', 
#'                        package = 'proActiv'), 
#'                        full.names = TRUE, pattern = 'replicate5')
#' promoterAnnotation <- promoterAnnotation.gencode.v34.subset
#' result <- proActiv(files = files,
#'                        promoterAnnotation  = promoterAnnotation,
#'                        condition = rep(c('A549', 'HepG2'), each=1),
#'                        fileLabels = NULL,
#'                        ncores = 1)
#'                            
proActiv <- function(files, promoterAnnotation, fileLabels = NULL, 
                    condition = NULL, genome = NULL, ncores = 1, 
                    fileType = NULL, apply_filter = FALSE, 
                    min_count = 10, min_prop = 0.7) {

    parser <- parseFile(files, fileLabels, genome, fileType)
    fileLabels <- parser$fileLabels
    fileType <- parser$fileType
    
    result <- buildSummarizedExperiment(promoterAnnotation, files, fileLabels,
                                        fileType, genome, ncores,
                                        condition, apply_filter, min_count, min_prop) 
    if (!is.null(condition)) {
        if (length(condition) != length(fileLabels)) {
            warning('Condition argument is invalid. 
                Please ensure a 1-1 map between each condition and each file.
                Returning results not summarized across conditions.')
            return(result)
        } else {
            result <- summarizeAcrossCondition(result, condition) 
        }
    }
    return(result) 
}

#' Integrate multiple proActiv runs 
#'
#' @param res1 A summarizedExperiment object returned by proActiv
#' @param res2 A summarizedExperiment object returned by proActiv
#' @param ... Additional summarizedExperiment objects returned by proActiv
#' @param promoterAnnotation Promoter annotation object used to create 
#'   proActiv runs
#' @param renormalize Whether to renormalize counts after merging. Defaults to 
#'   TRUE
#'
#' @export
#' @return A SummarizedExperiment object with assays giving promoter counts 
#'   and activity with gene expression. rowData contains
#'   promoter metadata and absolute promoter activity summarized across
#'   conditions (if condition is provided)
#' 
#' @examples
#' f1 <- list.files(system.file('extdata/vignette/junctions', 
#'                              package = 'proActiv'), 
#'                  full.names = TRUE, pattern = 'A549')
#' f2 <- list.files(system.file('extdata/vignette/junctions', 
#'                              package = 'proActiv'), 
#'                  full.names = TRUE, pattern = 'HepG2')
#' promoterAnnotation <- promoterAnnotation.gencode.v34.subset
#' res1 <- proActiv(files = f1, promoterAnnotation  = promoterAnnotation,
#'                  condition = rep('A549',3))
#' res2 <- proActiv(files = f2, promoterAnnotation = promoterAnnotation,
#'                  condition = rep('HepG2',3))
#' res <- integrateProactiv(res1, res2, promoterAnnotation = promoterAnnotation)
#'
#' @importFrom SummarizedExperiment assays `assays<-` cbind rowData `rowData<-`
integrateProactiv <- function(res1, res2, ..., 
                              promoterAnnotation,
                              renormalize = TRUE) {
    combined <- cbind(res1, res2, ...)
    if (renormalize) {
        promoterCounts <- assays(combined)$promoterCounts
        normalizedPromoterCounts <- normalizePromoterReadCounts(promoterCounts)
        absolutePromoterActivity <- getAbsolutePromoterActivity(
            normalizedPromoterCounts, promoterAnnotation)
        
        geneExpression <- getGeneExpression(absolutePromoterActivity)
        relativePromoterActivity <- getRelativePromoterActivity(
            absolutePromoterActivity, geneExpression)
        
        rownames(geneExpression) <- rownames(promoterCounts)
        fileLabels <- combined$sampleName
        assays(combined) <- list(promoterCounts = promoterCounts, 
            normalizedPromoterCounts = normalizedPromoterCounts, 
            absolutePromoterActivity = absolutePromoterActivity[, fileLabels, 
                                                                drop=FALSE], 
            relativePromoterActivity = relativePromoterActivity[, fileLabels, 
                                                                drop=FALSE],
            geneExpression = geneExpression[, fileLabels, drop=FALSE])    
        
        ## Settle rowData
        rowData(combined) <- rowData(combined)[-grep("mean|class", 
                                                colnames(rowData(combined)))]
        combined <- summarizeAcrossCondition(combined, combined$condition)
    }
    return(combined)
} 



# Helper function to impute file labels and infer file type
parseFile <- function(files, fileLabels, genome, fileType = NULL) {
    checkFile <- file.exists(files)
    if (any(!checkFile)) {
        stop(paste0('Error: Please specify valid file paths. 
                    The following file does not exist: ', files[!checkFile]))
    }
    
    if (is.null(fileLabels)) {
        fileLabels <- make.names(tools::file_path_sans_ext(basename(files), 
                                                            compression = TRUE),
                                unique = TRUE)
    }
    
    if (is.null(fileType)) {
        ext <- unique(tools::file_ext(files))
        if (length(ext) != 1) {
            stop("Error: More than one file type detected from given file path")
        }
        
        if (ext == 'gz' | ext == 'bz2' | ext == 'xz'){
            files.tmp <- gsub(paste0('\\.', ext), '', files)
            ext <- unique(tools::file_ext(files.tmp))
        }
        
        if (ext == 'bam') {
            fileType <- 'bam'
            if (is.null(genome)) {
                stop('Error: Please specify genome.')
            }
        } else if (ext == 'bed') {
            fileType <- 'tophat' 
        } else if (ext == 'junctions' | ext == 'tab') {
            fileType <- 'star'
        } else {
            stop('Invalid input files: Input must either be a BAM file (.bam), 
                Tophat junctions file (.bed) or 
                STAR junctions file (.junctions / .tab)')
        }
    }
    
    parsed <- list(fileLabels = fileLabels, fileType = fileType) 
    return(parsed)
}


#' Calculate Promoter Transcript Counts from Salmon Quantification
#'
#' This function processes Salmon transcript quantification files and aggregates 
#' them to promoter-level counts using promoter annotation information.
#'
#' @param files Character. Path to directory containing Salmon quant.sf files 
#'   or vector of paths to quantification directories.
#'   
#' @param promoterAnnotation A PromoterAnnotation S4 object with promoter 
#'   coordinates, transcript mapping, and intron ranges.
#'   
#' @param fileLabels Character vector. Sample labels for column names. 
#'   If NULL, uses directory names. Default NULL.
#'   
#' @param condition Character vector. Experimental conditions for each sample. 
#'   Used for filtering design matrix. Default NULL.
#'   
#' @param apply_filter Logical. Apply edgeR filtering to remove lowly 
#'   expressed promoters. Default TRUE.
#'   
#' @param min_count Numeric. Minimum count threshold for filtering. Default 10.
#'   
#' @param min_prop Numeric. Minimum proportion of samples that must meet 
#'   min_count threshold. Default 0.7.
#'
#' @return A list containing two elements:
#'   \item{promoterCounts}{A numeric matrix of promoter-level read counts with 
#'     promoters as rows and samples as columns. Row names are promoter IDs 
#'     and column names are sample labels.}
#'   \item{promoterAnnotation}{A filtered PromoterAnnotation object containing 
#'     only the promoters that passed filtering (if apply_filter=TRUE) or the 
#'     original annotation (if apply_filter=FALSE).}
#'
#' @details
#' The function performs the following steps:
#' \enumerate{
#'   \item Searches for Salmon quantification files (quant.sf)
#'   \item Imports transcript-level counts using edgeR::catchSalmon
#'   \item Maps transcripts to promoters using the provided annotation
#'   \item Aggregates transcript counts to promoter level by summing
#'   \item Optionally filters lowly expressed promoters using edgeR
#'   \item Returns both count matrix and filtered annotation
#' }
#'
#' @note 
#' - Requires the edgeR and data.table packages
#' - Salmon quantification files must be named "quant.sf"  
#' - The function handles overdispersion correction if present in Salmon output
#' - Filtering parameters should be adjusted based on experimental design
#'
#' @examples
#' \dontrun{
#' # Basic usage with directory containing Salmon output
#' result <- calculatePromoterTranscriptCounts(
#'   files = "path/to/salmon/output",
#'   promoterAnnotation = my_promoter_annotation
#' )
#' 
#' # With custom labels and conditions
#' result <- calculatePromoterTranscriptCounts(
#'   files = "path/to/salmon/output",
#'   promoterAnnotation = my_promoter_annotation,
#'   fileLabels = c("Control_1", "Control_2", "Treatment_1", "Treatment_2"),
#'   condition = c("Control", "Control", "Treatment", "Treatment"),
#'   apply_filter = TRUE,
#'   min_count = 5,
#'   min_prop = 0.5
#' )
#' 
#' # Access results
#' promoter_counts <- result$promoterCounts
#' filtered_annotation <- result$promoterAnnotation
#' }
#'
#' @seealso 
#' \code{\link[edgeR]{catchSalmon}}, \code{\link[edgeR]{filterByExpr}}, 
#' \code{\link[edgeR]{DGEList}}
#'
#' @export
calculatePromoterTranscriptCounts <- function(files, promoterAnnotation, 
                               fileLabels = NULL,
                               condition = NULL,
                               apply_filter = TRUE, 
                               min_count = 10, min_prop = 0.7) {

  # Find quant.sf files
  quant.files <- list.files(files, pattern = "quant.sf", 
                            recursive = TRUE, full.names = TRUE)
  
  if (length(quant.files) == 0) {
    stop("No quant.sf files found in ", files)
  }
  
  quant.dirs <- unique(dirname(quant.files))
  message("Found ", length(quant.dirs), " Salmon quantification directories")
  
  # Import using catchSalmon
  catch <- edgeR::catchSalmon(paths = quant.dirs)
  
  # Prepare count matrix
  if (!"Overdispersion" %in% colnames(catch$annotation)) {
    count_matrix <- catch$counts
  } else {
    count_matrix <- catch$counts / catch$annotation$Overdispersion
  }
  
  # Clean column names
  colnames(count_matrix) <- gsub(".*/", "", quant.dirs)
  
  # Create data frame for merging
  count_df <- data.frame(
    transcriptName = rownames(count_matrix),
    count_matrix,
    stringsAsFactors = FALSE
  )
  
  # Get promoter mapping
  promoterIdMap <- promoterIdMapping(promoterAnnotation)
  
  # Merge with promoter annotation
  transcripts_matched <- sum(count_df$transcriptName %in% promoterIdMap$transcriptName)
  message("Direct transcript ID matches: ", transcripts_matched, "/", nrow(count_df))
  
  merged_data <- merge(count_df, promoterIdMap, by = "transcriptName", all.x = FALSE)
  
  # Identify sample columns
  if (!is.null(fileLabels)) {
    if (length(fileLabels) != ncol(count_matrix)) {
      stop("Length of fileLabels must match number of samples")
    }
    colnames(count_matrix) <- fileLabels
  }
  sample_cols <- colnames(count_matrix)
  
  message("Using ", length(sample_cols), " samples for analysis")
  
  # Group by promoter
  merged_dt <- as.data.table(merged_data)
  promoter_data <- merged_dt[,
    lapply(.SD, sum, na.rm = TRUE),
    by = .(promoterId, geneId),
    .SDcols = sample_cols
  ]
  promoter_data <- as.data.frame(promoter_data)
  rownames(promoter_data) <- promoter_data$promoterId
  
  # Create DGEList
  count_matrix_final <- as.matrix(promoter_data[, sample_cols])
  dge_list <- edgeR::DGEList(counts = count_matrix_final)
  
  # Store original promoter annotation for filtering
  filtered_promoterAnnotation <- promoterAnnotation
  
  # Apply filtering if requested
  if (apply_filter) {
    message("Applying edgeR filtering")
    
    # Create design matrix based on condition parameter
    if (!is.null(condition) && length(condition) == length(sample_cols)) {
      # Create a data frame with condition information
      sample_data <- data.frame(
        sample = sample_cols,
        condition = condition,
        stringsAsFactors = FALSE
      )
      design <- model.matrix(~ condition, data = sample_data)
    } else {
      design <- model.matrix(~ 1, data = data.frame(sample = sample_cols))
    }
    
    keep <- edgeR::filterByExpr(dge_list, design = design, 
                               min.count = min_count, min.prop = min_prop)
    message("Filtering: kept ", sum(keep), "/", length(keep), " promoters")
    
    dge_list <- dge_list[keep, , keep.lib.sizes = FALSE]
    
    # Filter PromoterAnnotation S4 object to match filtered promoters
    kept_promoters <- rownames(dge_list$counts)
    
    # Filter the promoterIdMapping slot
    original_mapping <- promoterIdMapping(filtered_promoterAnnotation)
    filtered_mapping <- original_mapping[original_mapping$promoterId %in% kept_promoters, ]
    
    # Filter the promoterCoordinates slot
    original_coords <- promoterCoordinates(filtered_promoterAnnotation)
    coords_to_keep <- original_coords$promoterId %in% kept_promoters
    filtered_coords <- original_coords[coords_to_keep]
    
    # Filter the intronRanges slot - keep introns associated with retained promoters
    original_introns <- intronRanges(filtered_promoterAnnotation)
    # Get intron IDs associated with kept promoters
    if ("intronId" %in% colnames(filtered_coords)) {
      kept_intron_ids <- unlist(filtered_coords$intronId)
      introns_to_keep <- original_introns$INTRONID %in% kept_intron_ids
      filtered_introns <- original_introns[introns_to_keep]
    } else {
      filtered_introns <- original_introns[0]
    }
    
    # Create new filtered PromoterAnnotation object
    promoterIdMapping(filtered_promoterAnnotation) <- filtered_mapping
    promoterCoordinates(filtered_promoterAnnotation) <- filtered_coords
    intronRanges(filtered_promoterAnnotation) <- filtered_introns

    message("Filtered ", nrow(filtered_mapping), " transcripts retained")
    message("Filtered ", length(filtered_coords), " promoters retained")
    message("Filtered ", length(filtered_introns), " intron ranges retained")
  }
  
  promoterCounts <- round(dge_list$counts)
  
  # Quality control summary
  cat("\n=== FINAL SUMMARY ===\n")
  cat("Original transcripts:", nrow(count_df), "\n")
  cat("Transcripts with promoter annotation:", nrow(merged_data), "\n")
  cat("Unique promoters after aggregation:", nrow(promoter_data), "\n")
  cat("Final promoters:", nrow(promoterCounts), "\n")
  cat("Median counts per promoter:", median(rowSums(promoterCounts)), "\n")
  cat("Samples analyzed:", ncol(promoterCounts), "\n")

  # Return both filtered counts and annotation
  result <- list(
    promoterCounts = promoterCounts,
    promoterAnnotation = filtered_promoterAnnotation
  )
  
  return(result)
}


#' Build Summarized Experiment from promoter data
#'
#' This function builds a SummarizedExperiment object containing promoter counts,
#' normalized counts, absolute and relative promoter activity, and gene expression.
#'
#' @param promoterAnnotation A PromoterAnnotation object containing promoter annotations
#' @param files Character vector of file paths or directory containing quantification files
#' @param fileLabels Character vector of sample labels corresponding to files
#' @param fileType Character string specifying file type ("salmon", "bam", etc.)
#' @param genome Character string specifying genome build (e.g., "hg38", "mm10")
#' @param ncores Integer number of cores to use for parallel processing
#' @param condition Optional character vector specifying experimental conditions for each sample
#' @param apply_filter Logical indicating whether to apply filtering (default: TRUE)
#' @param min_count Minimum count threshold for filtering (default: 10)
#' @param min_prop Minimum proportion threshold for filtering (default: 0.7)
#'
#' @return A SummarizedExperiment object with promoter data and annotations
#'
#' @importFrom SummarizedExperiment SummarizedExperiment 'rowData<-'
#' @importFrom data.table as.data.table .N ':='
#' @importFrom rlang .data
#' @importFrom S4Vectors 'metadata<-'
#'
#' @export
buildSummarizedExperiment <- function(promoterAnnotation, 
                                        files, fileLabels, fileType, 
                                        genome, ncores,
                                        condition = NULL,
                                        apply_filter = TRUE, 
                                        min_count = 10, 
                                        min_prop = 0.7) {
    
    if (fileType == 'salmon') {
      calculatePromoter <- calculatePromoterTranscriptCounts(files, promoterAnnotation, 
                              fileLabels = fileLabels,
                              condition = condition,
                              apply_filter = apply_filter, 
                              min_count = min_count, 
                              min_prop = min_prop)
       
      promoterCounts <- calculatePromoter$promoterCounts
      promoterAnnotation <- calculatePromoter$promoterAnnotation
    }
    else {
      promoterCounts <- calculatePromoterReadCounts(promoterAnnotation, 
                                                    files, fileLabels, fileType, 
                                                    genome, ncores)
    }
    
    normalizedPromoterCounts <- normalizePromoterReadCounts(promoterCounts)
    absolutePromoterActivity <- getAbsolutePromoterActivity(
                                                    normalizedPromoterCounts, 
                                                    promoterAnnotation)
    geneExpression <- getGeneExpression(absolutePromoterActivity)
    rownames(geneExpression) <- rownames(promoterCounts)
    relativePromoterActivity <- getRelativePromoterActivity(
                                                    absolutePromoterActivity, 
                                                    geneExpression)
    result <- SummarizedExperiment(assays = list(
            promoterCounts = promoterCounts,
            normalizedPromoterCounts = normalizedPromoterCounts,
            absolutePromoterActivity = absolutePromoterActivity[, 
                                                    fileLabels, drop = FALSE],
            relativePromoterActivity = relativePromoterActivity[, 
                                                    fileLabels, drop = FALSE],
            geneExpression = geneExpression[, fileLabels, drop = FALSE]))
    
    message('Calculating positions of promoters...')
    promoterCoordinates <- promoterCoordinates(promoterAnnotation)
    promoterIdMapping <- promoterIdMapping(promoterAnnotation)
    promoterCoordinates$geneId <- promoterIdMapping$geneId[match(
                promoterCoordinates$promoterId, promoterIdMapping$promoterId)]
    promoterCoordinates <- as.data.table(promoterCoordinates)
    promoterPosition <- geneId <- strand <- NULL
    promoterCoordinates[, promoterPosition := ifelse(strand == '+', seq_len(.N), 
                                                rev(seq_len(.N))), by=geneId]
    ## Build row data
    rowData(result) <- data.frame(
                        absolutePromoterActivity[,c('promoterId', 'geneId')], 
                        promoterCoordinates[,c("seqnames","start", "strand",
                                    "internalPromoter", "promoterPosition")])
    transcriptByPromoter <- split(promoterIdMapping$transcriptName, 
                                promoterIdMapping$promoterId)
    rowData(result)$txId <- transcriptByPromoter[match(rowData(result)$promoterId, 
                                                names(transcriptByPromoter))]
    return(result)
}


# Helper function to summarize results across condition
#' @importFrom S4Vectors DataFrame metadata
#' @importFrom SummarizedExperiment rowData colData 'colData<-' assays
summarizeAcrossCondition <- function(result, condition) {
        if (any(make.names(condition) != condition)) {
            warning("Condition is modified to be syntactically valid")
            condition <- make.names(condition)
        }
        colData(result) <- DataFrame(sampleName = colnames(result), 
                                    condition=condition)
        colnames(result) <- colData(result)$sampleName
        message('Summarising expression and activity across conditions...')
        for (group in unique(condition)) {
            rowData(result)[,paste0(group, '.mean')] <- 
                rowMeans(assays(result[,colData(result)$condition==group])$abs) 
            rowData(result)[,paste0(group, '.gene.mean')] <- 
                rowMeans(assays(result[,colData(result)$condition==group])$gene)
        }
        rowData(result) <- categorizePromoters(rowData(result), condition)
    return(result)
}

# Helper function to categorize promoters
#' @importFrom rlang .data
#' @importFrom dplyr as_tibble '%>%' slice_max
categorizePromoters <- function(rdata, condition) {
    rdata <- as_tibble(rdata)
    for (group in unique(condition)) {
        message(paste0('Categorizing ', group, ' promoters...'))
        mean <- paste0(group, '.mean')
        class <- paste0(group, '.class')
        
        max_rows <- rdata %>%
            group_by(.data$geneId) %>%
            slice_max(!!as.name(mean), with_ties = FALSE)
        rdata[[class]] <- ifelse(rdata[[mean]] < 0.25, 'Inactive', 'Minor')
        rdata[[class]][match(max_rows$promoterId, rdata$promoterId)] <- "Major"
        rdata[[class]][which(rdata[[mean]] < 0.25)] <- "Inactive"
        rdata[[class]][which(rdata$internalPromoter)] <- NA
        rdata[[class]][which(is.na(rdata$internalPromoter))] <- NA
    }
    return(rdata)
}
